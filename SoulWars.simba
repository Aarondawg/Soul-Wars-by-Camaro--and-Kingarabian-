program SW;
{$DEFINE SMART}
{$I SRL/SRL.simba}
{$I SRL/SRL/misc/debug.simba}
{Read: Debugging 9/10 time causes Simba to lose focus of Runescape. Right now a lot of the previous functions are acting up.
Colors need to be updated? To tired right now lol will continue working tomorrow.
Also if a player is covering the barrier in the graveyard our function screws up.
Some work to do but will figure it out. I'll continue learning and will reach our potential. }




const
  DebugScript = True;
  //Removed ur other const, cause its the same thing as this one
  Team = 'Random'; // Random, Last Won, Last Lost , Always Red, Always Blue,



const
  SW_ROADCOLOR    = 6846589 ; // Color of the roads out side of the game. (gray)
  SW_TREECOLOR    = 1071141 ; // Tree color outside of the game (Green)
  SW_WATERCOLOR   = 9932162 ; // Water surronding blue waiting room ( blue)
  SW_LAVACOLOR    = 1880011 ; // Lava surrounding the red waiting room (orange/yellowish)
  DOORCOLOR       = 67059   ; // Any door color (MM)
  MS_BARRIER_RED  = 5659569 ; // Barrier color of red team. MS
  MS_BARRIER_BLUE = 11234661; // Barrier color of blue team. MS
  WARNING_TEXT    = 2302945 ; // Chat box warning text when you go to join a game
  ARROW_MM_WHITE  = 15790834; // White arrow in game MM
  ARROW_MM_BLUE   = 16745299; // blue arrow in game MM
  ARROW_MM_RED    = 7901    ; // reed arrow in game MM
  BLUE_NPC_MM     = 14519141; // Blue dots on MM
  WAITING_TEXT    = 39423   ; // Orange text to detect if we are in the waiting room



var
  TeamOn : String;
  RecentDead, InWaitingRoom2, WalkFurther: Boolean;


procedure DeclarePlayers;
begin
  HowManyPlayers := 1; // Number of Players to use
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0; // Player to start with, first one is 0
  Players[0].Name := 'hi'; // Username
  Players[0].Pass := ''; // Password
  Players[0].Active := True; // True if you are using this player
  Players[0].Pin := ''; // Bank Pin. Leave it if you don't have one.
end;

procedure Debug(S: String);
begin
  if (DebugScript) then
    Writeln(s);
end;

Function CheckGameInSession: Boolean; //Text in  box telling you that a game is in session and if you want to continue regardless.
  begin
   {If FindText() then
   ChooseOption;}
  end;

Function CheckIsKicked: Boolean;  //To-be continued   Basically a chat box will appear telling you that you are banned from the game. Indicates time remaining.
begin
 {if FindText()}
end;


function InWaitingRoom: Boolean;
var
  I : Integer;
begin
  Result := GetColor(418, 33) = WAITING_TEXT; //Orange color in text
  if (not(Result)) then
  begin
    for I := 0 to 20 do
    begin
      Result := GetColor(418 + I, 33) = WAITING_TEXT; //Orange color in text
      if (Result) then Exit;
    end;
  end;

end;

function InGame : Boolean; //It doesn't matter which team your on to do this check btw, i showed u somewhere how simple it was to do this function  ;)
begin
  Result := GetColor(426, 144) = 39423;
end;


{function InGame: Boolean;  //To-be heavily optimized. I know, I know it looks really ugly. Sorry bare with me. However the colors should work. Tested througly.
  var
  x,y,CTS: Integer;
begin
  CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
    If  (Lowercase(Team) = 'red') then
    begin
      SetColorSpeed2Modifiers(0.73, 1.56);
    if  FindColorSpiralTolerance(x, y, 1118245, MSX1, MSY1, MSX2, MSY2, 1) then
    begin
      writeln('Found Red team');
        ColorToleranceSpeed(CTS);
          SetColorSpeed2Modifiers(0.2, 0.2);
            Result:= True;
            end;
end else
    if (Lowercase(Team) = 'blue') then
     CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.43, 7.28);
    if FindColorSpiralTolerance(X, Y, 2562576, MSX1, MSY1, MSX2, MSY2, 1) then
     writeln('Found Blue Team');
        ColorToleranceSpeed(CTS);
          SetColorSpeed2Modifiers(0.2, 0.2);
            Result:= True;
     end;
}


function DetermineTeamToJoin: String;
begin  //Red or Blue
  if (TeamOn = '') then
  begin
    if (Team = 'Random') then
    begin
      if (Random(2) = 1) then
        Result := 'Blue'
      else
        Result := 'Red';
    end;
    TeamOn := Result;
  end else
  begin
    Result := TeamOn;
  end;
  Debug('Team : '+ToStr(Result)+'');
end;

function CompassNorth : Boolean;//gets the compass and checks if ur facing north
var
  C : Integer;
begin
  C := Round(RS_GetCompassAngleDegrees);
  if ((InRange(c, 340, 360)) or (InRange(c, 0, 20)))then
    Result := True;
end;


function NearBank : Boolean;
var
  TPA : TPointArray;
begin
  if not LoggedIn then Exit;

  if (not(CompassNorth)) then
    Exit;
  if (InWaitingRoom) then Exit;
  FindColorsTolerance(TPA, SW_TREECOLOR, 605, 12, 664, 39, 15);//Box on northern part of MM(alot of trees)
  Debug('Length of MM Trees TPA: '+ToStr(Length(TPA))+'');
  if (Length(TPA) > 680) then
  begin
    Result := True;
    Debug('Player: Near Bank'); //looks for the trees (if u stand by bank u see them north of u) looks for those
  end;
end;



function GetGraveYardDoor : TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  Result := Point(-1, -1);
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 2);
  SortATPAFrom(ATPA, Point(MMCY, MMCY));
  DebugATPA(ATPA, '');
  for A := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from graveyard door TPoint: '+ToStr(Distance(x, y, mmcx, MMCy)));
    if (Distance(x, y, MMCX, mmcy) < 35) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 <=  2) and (bBox.Y2 - bBox.Y1 <= 2) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;


function SameArrowTP: Tpoint;

var
  A, X, Y, Width, Height : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  if (not(CompassNorth)) then
  MakeCompass('N');
  if (DetermineTeamToJoin = 'Red') then
    FindColorsTolerance(TPA, ARROW_MM_Red , MMX1, MMY1, MMX2, MMY2, 20)
  else
    FindColorsTolerance(TPA, ARROW_MM_BLUE , MMX1, MMY1, MMX2, MMY2, 20);
  ATPA := TPAToATPAEx(TPA, 4,4);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from arrow MM: '+ToStr(Distance(x, y, MMCX, MMCy)));
    bBox := GetTPABounds(ATPA[A]);
    Debug('ARROW Mm width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('ARROW Mm height: '+ToStr(bBox.y2 - bBox.y1)+'');
    Width := (BBox.X2-BBox.X1);
    Height := (BBox.Y2-BBox.Y1);

    If (Distance(X, Y, MMCX, MMCY) >= 40) then
    begin
      If (Width <= 5) and (Height <= 5) and (Width >= 1) and (Height >= 1) then
      begin
        Debug('Found Arrow');
        Result := Point(x,y);
        Exit;
      end;
    end;
  end;
end;

function AnyNPCOnScreen: Boolean;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;

begin
 //if not (LoggedIn) then Exit;
 FindColorsTolerance(TPA, 193785 , MMX1, MMY1, MMX2, MMY2, 20);
 ATPA := TPAToATPA(TPA, 7);
 if (Length(ATPA) > 1) then
   Result := True;
end;

function InGraveYard : Boolean;
var
  I, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  TB : TBox;
  TP: TPoint;
begin
  if not LoggedIn then Exit;

  if (InWaitingRoom) then Exit;
  if (not(InGame)) then Exit;
  if (AnyNPCOnScreen) then Exit;
  if (not(CompassNorth)) then
    MakeCompass('n');
  FindColorsTolerance(TPA, 15987435, 593, 46, 658, 116, 25);
  Debug('Length of walls TPA: '+ToStr(Length(TPA))+'');
  ATPA := TPAToATPAEx(TPA, 35, 55);
  DebugATPA(ATPA, '');
  writeln('Length of potential graveyards: '+ToStr(Length(ATPA))+'');
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[i], x, y);
    TB := GetTPABounds(ATPA[i]);
    debug('walls = '+tostr(tb.x2 - tb.x1)+ ', '+tostr(tb.y2- tb.y1)+'');
    if ((tb.x2 - tb.x1) > 20) and ((tb.y2 - tb.y1) > 35) then
    begin
      if (PointInBox(Point(MMCX, MMCY), TB)) then   //MMCX , MMCY
      begin
        Debug('Maybe In Graveyard');

        TP := GetGraveYardDoor;
        if (DetermineTeamToJoin = 'Blue') then
        begin
          if (MMCX > TP.X) then
          begin
            Result := True;
            Debug('In Graveyard');
            Exit;
          end;
        end;
        if (DetermineTeamToJoin = 'Red') then
        begin
          if (MMCX < TP.X) then
          begin
            Result := True;
            Debug('In Graveyard');
            Exit;
          end;
        end;
        TP := SameArrowTP;
        if (DetermineTeamToJoin = 'Red') then
        begin
          if (TP.Y > MMCY) and (TP.X > MMCX) then
          begin
            Result := True;
            Debug('In Graveyard');
            Exit;
          end;
        end else
        begin
          if (TP.Y < MMCY) and (TP.X < MMCX) then
          begin
            Result := True;
            Debug('In Graveyard');
            Exit;
          end;
        end;
      end;
    end;
    Wait(25);
  end;
end;


function WhiteArrowDistance(Click : Boolean; MinDist: Integer): Boolean; //Click [True/False] - Click the arrow if we are atleast MinDist away

var
  A, X, Y, Width, Height, d : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  writeln('s');
  if (not(CompassNorth)) then
  MakeCompass('N');
  FindColorsTolerance(TPA, ARROW_MM_WHITE , MMX1, MMY1, MMX2, MMY2, 20);
  ATPA := TPAToATPAEx(TPA, 4,4);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from arrow MM: '+ToStr(Distance(x, y, MMCX, MMCy)));
    bBox := GetTPABounds(ATPA[A]);
    Debug('ARROW Mm width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('ARROW Mm height: '+ToStr(bBox.y2 - bBox.y1)+'');
    Width := (BBox.X2-BBox.X1);
    Height := (BBox.Y2-BBox.Y1);
    d := Distance(X, Y, MMCX, MMCY);
    If (Width <= 5) and (Height <= 5) and (Width >= 1) and (Height >= 1) then
    begin
      Debug('Arrow is the right size');
      if (d > MinDist) then
      begin
        Result := True;
        if (Click) then
        begin
          Mouse(X, Y, 7, 7, True);
          Wait(500 + Random(500));
          FFlag(0);
        end;
        Exit;
      end;
    end;
  end;
end;

function ClickOtherArrow: Boolean;

var
  A, X, Y, Width, Height : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  if (not(CompassNorth)) then
  MakeCompass('N');
  if (DetermineTeamToJoin = 'Red') then
    FindColorsTolerance(TPA, ARROW_MM_BLUE , MMX1, MMY1, MMX2, MMY2, 20)
  else
    FindColorsTolerance(TPA, ARROW_MM_RED , MMX1, MMY1, MMX2, MMY2, 20);
  ATPA := TPAToATPAEx(TPA, 4,4);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from arrow MM: '+ToStr(Distance(x, y, MMCX, MMCy)));
    bBox := GetTPABounds(ATPA[A]);
    Debug('ARROW Mm width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('ARROW Mm height: '+ToStr(bBox.y2 - bBox.y1)+'');
    Width := (BBox.X2-BBox.X1);
    Height := (BBox.Y2-BBox.Y1);

    If (Distance(X, Y, MMCX, MMCY) >= 40) then
    begin
      If (Width <= 5) and (Height <= 5) and (Width >= 1) and (Height >= 1) then
      begin
        Debug('Found Arrow');
        Result := True;
        X := X + RandomRange(-4, 4);
        Y := Y + RandomRange(-4, 4);
        if (RS_OnMinimap(X, y)) then
        begin
          Mouse(X, Y, 0, 0, True);
          //Wait(4500 + Random(5000));
          Wait(250 + Random(250));
          FFlag(0);
        end;

      end;
    end;
  end;
end;




function RotatePointEx(p, o:tPoint; d:Extended):TPoint ;
begin
  p.x := p.x + (0 - o.x);
  p.y := p.y + (0 - o.y);

  Result.x := (round(p.x * cos(d * (PI / 180)) -  (p.y * sin(d * (PI / 180))))) - o.x * -1;
  Result.y := (round(sin(d * (PI / 180)) * p.x + cos(d * 1 * (PI / 180)) * p.y)) - o.y * -1;
end;

function Walking(Color, Tolerance: Integer; SortFrom: TPoint; RX, RY: Integer): Boolean;
var
  i, x, y, a : Integer;
  TPA: TPointArray;
  xT : TPoint;
begin
  if not LoggedIn then Exit;
  FindNormalRandoms;
  a := round(RS_GetCompassAngleDegrees);
  a := (360 - a);
  xT := RotatePointEx(SortFrom, Point(MMCX,MMCY), a);
  FindColorsSpiralTolerance(MMCX, MMCY, TPA, Color, MMX1, MMY1, MMX2, MMY2, Tolerance);
  if (Length(TPA) < 10) then Exit;

  SortTPAFrom(TPA, XT);

  for i := 0 to High(TPA) do
  begin
    x := TPA[i].x;
    y := TPA[i].y;

    rx := RandomRange(-rx, rx);
    ry := RandomRange(-ry, ry);
    if (not rs_OnMinimap(x + rx, y + ry)) then
      Continue;

    Mouse(x + rx, y + ry, 0, 0, true);
    FFlag(0);
    Wait(700 + Random(500));
    Result := True;
    Break;
  end;
end;

function ByPassWarning : Boolean;
var I : Integer;
begin
  if FindNPCChatText('inutes', Nothing) then
  begin
    Debug('Waiting a minute to wait for this warning to leave');
    Wait(55000 + Random(10000));
    MMouse(Random(500), Random(500), 0, 0);
    Mouse(260, 470, 14, 4, True);
    Exit;
  end;
  for I := 0 to 30 do
  begin
    if (GetColor(41 + I, 406 + Random(3)) = WARNING_TEXT) then
    begin
      Mouse(260, 470, 15, 4, True);
      Wait(1250 + Random(1500));
      Mouse(258, 408, 15, 4, True);
      Wait(1250 + Random(1500));
      Result := True;
    end;
  end;
  Result := True;
end;




function FindBarrierGame(x1, y1, x2, y2: Integer): Boolean; //continues to work all right

var
  A, X, Y, K: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  if (DetermineTeamToJoin = 'Red') then
    FindColorsTolerance(TPA, MS_BARRIER_RED, x1, y1 , x2 , y2  , 20 )
  else
    FindColorsTolerance(TPA, MS_BARRIER_BLUE, x1 , y1, x2 , y2 , 20 );
  ATPA := TPAToATPAEx(TPA, 3,3);//split the big tpa into small boxs
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin

    MiddleTPAEx(ATPA[A], X, Y);
    if (not(PointInBox(Point(X, Y), IntToBox(263, 21, 384, 64)))) then
    begin
      Debug('Distance from door: '+ToStr(Distance(x, y, MSCX, MSCY)));
      if ((Distance(x, y, MSCX, MSCY)) < 325) then  //if we are close to barrier
      begin
        bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
        Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
        Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
        if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 1) then  //if its this big
        begin
          if (X < 1) or (Y < 1) then
            Continue;
          Mouse(X, Y, 6, 6, False);   //goo!!!!!!
          if (WaitOption('arrier', 1500)) then
          begin
            FFlag(0);
            Wait(1500 + Random(2000));
            Result := True;
            SetAngle(0);
            MakeCompass('n');
            InWaitingRoom2 := False;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;



procedure STARTREDWAITINGROOM;
begin
end;

function GetRedWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, SW_LAVACOLOR, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);
  DebugATPA(atpa, '');
  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Lava width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Lava height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Lava TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetRedWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetRedWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToRedWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetRedWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance');
  TP := GetRedWaitingRoom;                   //IF RED DOOR IS COVER ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance : 2');
end;

function EnterRedWaitingRoom: Boolean;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('E');
  FindColorsTolerance(TPA, MS_BARRIER_RED, 162, 68, 363, 218, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 3,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 65) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          if (ByPassWarning) then
          begin
            Result := True;
            FFlag(0);

            MakeCompass('N');
            SetAngle(0);
            Wait(1500 + Random(1500));
            if (Random(3) = 1) then
            begin
              Mouse(MSCX + 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end else
          begin
            if (Random(3) = 1) then
            begin
              Mouse(MSCX + 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;

procedure ENDREDWAITINGROOM;
begin
end;

function GetNPCsATPA: TPointArray;
var
  TPA: TPointArray;


begin
 //if not (LoggedIn) then Exit;
 FindColorsTolerance(TPA, BLUE_NPC_MM, MMX1, MMY1, MMX2, MMY2, 20);
 Result := TPA;
end;

function LeaveCrowdedGrave: Boolean;
var
  TPA, TPA2: TPointArray;
  ATPA: T2DPointArray;
  I, X, Y, R : Integer;
begin
  TPA := GetNPCsATPA;
  writeln(length(tpa));
  ATPA := SplitTPA(TPA, 16);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[i], X, Y);
    if (Distance(X, Y, MMCX, MMCY) < 25) then
    begin
      if (DetermineTeamToJoin = 'Blue') then
        R := -6
      else
        R := 6;
      Mouse(X + R, Y + R, 3, 3, True);
      FFlag(0);
      Wait(500 + Random(500));
      SetAngle(1);
      if (DetermineTeamToJoin = 'Blue') then
      begin
        MakeCompass('e')
        if (FindBarrierGame(MSX1, MSY1, MSX2, MSY2)) then
        begin
          SetAngle(0);
          MakeCompass('n');
          Result := True;
          Exit;
        end;
      end else
      begin
        MakeCompass('w');
        if (FindBarrierGame(MSX1, MSY1, MSX2, MSY2)) then
        begin
          SetAngle(0);
          MakeCompass('n');
          Result := True;
          Exit;
        end;
      end;
      SetAngle(0);
      MakeCompass('n');
    end;
  end;
end;


function InSmallGrave: Boolean;
begin

end;


procedure DoFight;
begin
end;

function WalkAndCheckDead(Grave: Integer): Boolean;
begin
end;

function FindBlueBarrier: Boolean;
var
  X, Y, I, A, Height, Width: Integer;//I dont know why i added'a' yet
  TPA : array of TPoint; //Same thing
  ATPA : T2DPointArray;
  bBox : TBox;

begin
  if not LoggedIn then Exit;
  Walking(4619616 , 15, Point(607, 92), 5, 5); //attempts to walk near the barrier..
  SetAngle(1);
  MakeCompass('E');
  FindColorsTolerance(TPA, 10056026 , MSX1, MSY1, MSX2, MSY2, 15);
  ATPA := TPAToATPAEx(TPA, 50, 50);
  SortATPAFrom(ATPA, Point(MSCX, MSCY));
  //DebugATPA(ATPA, '');
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[I], X, Y);
    If (X < 1) or (Y < 1) then
    begin
      Writeln('0');
      Continue;
    end;
    if (Y > MSCY) then
    begin
      Writeln('1');
      BBox :=  GetTPABounds(ATPA[I]);
      Width := (BBox.X2-BBox.X1);
      Height := (BBox.Y2-BBox.Y1);
      WriteLn('Width:'+ToStr(Width));
      WriteLn('Height:'+ToStr(Height));
      If (Width >= 22) and (Height >= 10) then
      begin
        Writeln('2');
        MMouse(X, Y, 6, 3);
        Wait(100+Random(50));
        if IsUpText('arrie') then
        begin
          GetMousePos(X, Y);
          Mouse(X, Y, 0, 0, True);
          FFlag(0);
          Wait(400+Random(125));
          Result:=True;
          Makecompass('n');
          setangle(0);
          Exit;
       end;
      end;
   end;
  end;
end;
function FindRedBarrier: Boolean;
var
  X, Y, I, A, Height, Width: Integer;//I dont know why i added'a' yet
  TPA : array of TPoint; //Same thing
  ATPA : T2DPointArray;
  bBox : TBox;

begin
  if not LoggedIn then Exit;
  Walking(2827565, 15, Point(638, 84), 5, 5);
 // SetAngle(1);
  MakeCompass('W');
  FindColorsTolerance(TPA, 5923013, MSX1, MSY1, MSX2, MSY2, 15);
  ATPA := TPAToATPAEx(TPA, 50, 50);
  SortATPAFrom(ATPA, Point(MSCX, MSCY));//Sorting thru the ATPA
  //DebugATPA(ATPA, '');
  for I := 0 to High(ATPA) do   //looping...
  begin
    MiddleTPAEx(ATPA[I], X, Y);
    If (X < 1) or (Y < 1) then //dunno why i have this here
    begin
      Writeln('0');
      Continue;
    end;
    if (Y > MSCY) then
    begin
      Writeln('1');
      BBox :=  GetTPABounds(ATPA[I]);
      Width := (BBox.X2-BBox.X1);
      Height := (BBox.Y2-BBox.Y1);
      WriteLn('Width:'+ToStr(Width));
      WriteLn('Height:'+ToStr(Height));
      If (Width >= 22) and (Height >= 10) then
      begin
        Writeln('2');
        MMouse(X, Y, 6, 3);
        Wait(100+Random(50));
        if IsUpText('arrie') then
        begin
          GetMousePos(X, Y);
          Mouse(X, Y, 0, 0, True);
          FFlag(0);
          Wait(400+Random(125));
          Result:=True;
          Makecompass('n');
          Exit;
        end;
      end;
   end;
  end;
end;

function GameLoop: Boolean; //Gets repeated as long as we are in the game
var
  TP : TPoint;
  T, HP, B: Integer;
begin
  if not (InGame) then Exit;

  Result := True;
  if (InGraveYard) or (InWaitingRoom2) then
  begin
    TP := GetGraveYardDoor;
    //Mouse(TP.X, TP.Y, 2, 1, True) ;
    FFlag(0);
  //  SetAngle(1);
    if (DetermineTeamToJoin = 'Red') then
      FindRedBarrier
    else
      FindBlueBarrier;


  end else
  begin
    if (not(ClickOtherArrow)) then
      DoFight;
  end;

end;


procedure STARTBLUEWAITINGROOM;
begin
end;

function GetBlueWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, SW_WATERCOLOR, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);
  DebugATPA(atpa, '');

  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Water width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Water height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Water TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetBlueWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetBlueWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToBlueWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetBlueWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance');
  TP := GetBlueWaitingRoom;                   //IF BLUE DOOR IS COVERed ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance : 2');
end;

function EnterBlueWaitingRoom: Boolean;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('W');
  FindColorsTolerance(TPA, MS_BARRIER_BLUE, 162, 68, 363, 218, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 3,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 65) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          if (ByPassWarning) then
          begin
            Result := True;
            FFlag(0);

            MakeCompass('N');
            SetAngle(0);
            Wait(1500 + Random(1500));
            if (Random(3) = 1) then
            begin
              Mouse(MSCX - 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));

            end;
            Exit;
          end else
          begin
            if (Random(3) = 1) then
            begin
              Mouse(MSCX - 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;

procedure ENDBLUEWAITINGROOM;
begin
end;

function GetLoc: String;
begin
  if (not(InGame)) then //If not in the game
  begin
    if (NearBank) then // If we are near the bank
    begin
      Result := 'LeaveBank';//Tell main loop to walk toward the middle of the two islands
      Exit;
    end else   // if we are not in game and not by bank
    begin
      if (InWaitingRoom) then // check if were in waiting room (Simple boolean)
      begin
        Result := 'Waiting Room';
        InWaitingRoom2 := True;
        Exit;
      end;                  //if not, lets GOOO!
      Result := 'EnterWaitingRoom';
    end;
  end else
  begin
    Result := 'InGame';  //in game time
  end;

end;

begin
  Smart_Server := 44;
  Smart_Members := True;
  Smart_Signed := True;
  Smart_SuperDetail := False;
  SetupSRL;
  Reincarnate:=true;

  DeclarePlayers;
  ActivateClient;
  Mouse(88, 493, 8, 8, True);//Set chat -> Game
  TeamOn := 'Blue'; //for now just set this...
  inwaitingroom2 := false;   //leave this to true if ur starting in the aiting room or ion the graveyard
 // writeln(ingraveyard);
  //Getgraveyarddoor;
  //enterRedwaitingroom;
  //findbarriergame(162, 68, 363, 218);

  //leavecrowdedgrave;
// terminatescript;
  repeat
    if (InGame) then
    begin
      Disguise('InGame');
    end;
    if (InWaitingRoom) then
      Disguise('InWaitingRoom');
    //if (Random(2) = 1) then Debug(GetLoc);    //So the debug box doesnt get spammed
    case GetLoc of
      'LeaveBank':
      begin
        Walking(6713205, 15, Point(627, 146), 5, 5); // if Near the bank walk south to the middle of both boxes
      end;
      'EnterWaitingRoom':
      begin
        if (not(CompassNorth)) then // If your compass is east/west already from a previous attempt, then just try again
        begin
          if (DetermineTeamToJoin = 'Red') then
            EnterRedWaitingRoom;
          if (DetermineTeamToJoin = 'Blue') then
            EnterBlueWaitingRoom;

        end else
        begin
          if (DetermineTeamToJoin = 'Red') then
          begin
            if (WalkToRedWaitingEntrance) then  //Walks to the red
            begin
              EnterRedWaitingRoom;
            end;
          end;
          if (DetermineTeamToJoin = 'Blue') then
          begin
            if (WalkToBlueWaitingEntrance) then  //Walks to the blue
            begin
              EnterBlueWaitingRoom;
            end;
          end;
        end;
      end;
      'WaitingRoom':
      begin
        InWaitingRoom2 := True;
        Wait(1250 + Random(1250));
        if (Random(30) = 5) then
          MMouse(Random(500), Random(500), 0, 0);
      end;
      'InGame':
      begin
        GameLoop;
      end;
    end;
  until False
end.
