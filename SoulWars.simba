program SW;
{$I SRL/SRL.simba}
{$I SRL/SRL/misc/debug.simba}
{Read: Debugging 9/10 time causes Simba to lose focus of Runescape. Right now a lot of the previous functions are acting up.
Colors need to be updated? To tired right now lol will continue working tomorrow.
Also if a player is covering the barrier in the graveyard our function screws up.
Some work to do but will figure it out. I'll continue learning and will reach our potential. }
const
  DebugScript = True;
  //Removed ur other const, cause its the same thing as this one
  Team = 'Last Won'; // Random, Last Won, Last Lost , Always Red, Always Blue,

var
  InWaitingRoom2: Boolean;

procedure DeclarePlayers;
begin
  HowManyPlayers := 1; // Number of Players to use
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0; // Player to start with, first one is 0
  Players[0].Name := 'hi'; // Username
  Players[0].Pass := ''; // Password
  Players[0].Active := True; // True if you are using this player
  Players[0].Pin := ''; // Bank Pin. Leave it if you don't have one.
end;

procedure Debug(S: String);
begin
  if (DebugScript) then
    Writeln(s);
end;

Function CheckGameInSession: Boolean; //Text in  box telling you that a game is in session and if you want to continue regardless.
  begin
   {If FindText() then
   ChooseOption;}
  end;

Function CheckIsKicked: Boolean;  //To-be continued   Basically a chat box will appear telling you that you are banned from the game. Indicates time remaining.
begin
 {if FindText()}
end;


function InWaitingRoom: Boolean;
begin
  Result := GetColor(418, 29) = 39423; //Orange color in text
  Result := GetColor(429, 36) = 39423; //Extra
end;

function InGame : Boolean; //It doesn't matter which team your on to do this check btw, i showed u somewhere how simple it was to do this function  ;)
begin
  Result := GetColor(426, 144) = 39423;
end;


{function InGame: Boolean;  //To-be heavily optimized. I know, I know it looks really ugly. Sorry bare with me. However the colors should work. Tested througly.
  var
  x,y,CTS: Integer;
begin
  CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
    If  (Lowercase(Team) = 'red') then
    begin
      SetColorSpeed2Modifiers(0.73, 1.56);
    if  FindColorSpiralTolerance(x, y, 1118245, MSX1, MSY1, MSX2, MSY2, 1) then
    begin
      writeln('Found Red team');
        ColorToleranceSpeed(CTS);
          SetColorSpeed2Modifiers(0.2, 0.2);
            Result:= True;
            end;
end else
    if (Lowercase(Team) = 'blue') then
     CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.43, 7.28);
    if FindColorSpiralTolerance(X, Y, 2562576, MSX1, MSY1, MSX2, MSY2, 1) then
     writeln('Found Blue Team');
        ColorToleranceSpeed(CTS);
          SetColorSpeed2Modifiers(0.2, 0.2);
            Result:= True;
     end;
}


function DetermineTeamToJoin: String;
begin  //Red or Blue
  Result := 'Blue';// If Team = 'last won' then determine that, and do result := blue... or w.e.......
end;

function CompassNorth : Boolean;//gets the compass and checks if ur facing north
var
  C : Integer;
begin
  C := Round(RS_GetCompassAngleDegrees);
  if ((InRange(c, 340, 360)) or (InRange(c, 0, 20)))then
    Result := True;
end;


function NearBank : Boolean;
var
  TPA : TPointArray;
begin
  if not LoggedIn then Exit;

  if (not(CompassNorth)) then
    Exit;
  if (InWaitingRoom) then Exit;
  FindColorsTolerance(TPA, 1136677, 605, 12, 664, 39, 10);//Box on northern part of MM(alot of trees)
  Debug('Length of MM Trees TPA: '+ToStr(Length(TPA))+'');
  if (Length(TPA) > 680) then
  begin
    Result := True;
    Debug('Player: Near Bank'); //looks for the trees (if u stand by bank u see them north of u) looks for those
  end;
end;

function CountWallPixels : Integer;
var
  I, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  TB : TBox;
begin
  if not LoggedIn then Exit;

  //if (InWaitingRoom) then Exit;
  FindColorsTolerance(TPA, 15528438, MMCX - 55, MMCY - 55, MMCX + 55, MMCY + 55, 10);//Box for walls    //MMx1, MMy1, MMx2, mmy2
  Debug('Length of walls TPA: '+ToStr(Length(TPA))+'');
  Result := Length(TPA);
 { ATPA := TPAToATPA(TPA, 5);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  debugaTPA(atpa, '');
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[i], x, y);
    debug('dist = '+tostr(distance(X, y, mmcx, mmcy))+'');
    if (distance(X, y, mmcx, mmcy) < 21) then
    begin
      IncEx(Result, Length(ATPA[i]));
    end;
  end;
      }

  debug('result = '+tostr(tostr(result)));
  {if (Length(TPA) > 680) then
  begin

    Result := True;
    Debug('Player: Near Bank'); //looks for the trees (if u stand by bank u see them north of u) looks for those
  end; }
end;

function RotatePointEx(p, o:tPoint; d:Extended):TPoint ;
begin
  p.x := p.x + (0 - o.x);
  p.y := p.y + (0 - o.y);

  Result.x := (round(p.x * cos(d * (PI / 180)) -  (p.y * sin(d * (PI / 180))))) - o.x * -1;
  Result.y := (round(sin(d * (PI / 180)) * p.x + cos(d * 1 * (PI / 180)) * p.y)) - o.y * -1;
end;

function Walking(Color, Tolerance: Integer; SortFrom: TPoint; RX, RY: Integer): Boolean;
var
  i, x, y, a : Integer;
  TPA: TPointArray;
  xT : TPoint;
begin
  if not LoggedIn then Exit;
  FindNormalRandoms;
  a := round(RS_GetCompassAngleDegrees);
  a := (360 - a);
  xT := RotatePointEx(SortFrom, Point(MMCX,MMCY), a);
  FindColorsSpiralTolerance(MMCX, MMCY, TPA, Color, MMX1, MMY1, MMX2, MMY2, Tolerance);
  if (Length(TPA) < 10) then Exit;

  SortTPAFrom(TPA, XT);

  for i := 0 to High(TPA) do
  begin
    x := TPA[i].x;
    y := TPA[i].y;

    rx := RandomRange(-rx, rx);
    ry := RandomRange(-ry, ry);
    if (not rs_OnMinimap(x + rx, y + ry)) then
      Continue;

    Mouse(x + rx, y + ry, 0, 0, true);
    FFlag(0);
    Wait(700 + Random(500));
    Result := True;
    Break;
  end;
end;

function ByPassWarning : Boolean;
begin
  if FindNPCChatText('inutes', Nothing) then
  begin
    Debug('Waiting a minute to wait for this warning to leave');
    Wait(55000 + Random(10000));
    MMouse(Random(500), Random(500), 0, 0);
    Mouse(260, 470, 14, 4, True);
    Exit;
  end;
  if (GetColor(83, 408) = 2302945) then
  begin
    Mouse(260, 470, 15, 4, True);
    Wait(1250 + Random(1500));
    Mouse(258, 408, 15, 4, True);
    Wait(1250 + Random(1500));
    Result := True;
  end;
  Result := True;
end;


function FindRedBarrier: Boolean; //continues to work all right
var
  X, Y, I, Height, Width: Integer;//I dont know why i added'a' yet
  TPA : array of TPoint; //Same thing
  ATPA : T2DPointArray;
  bBox : TBox;

begin
  if not LoggedIn then Exit;
  //SetAngle(false);
  MakeCompass('W');
  FindColorsTolerance(TPA,4738191, MSX1, MSY1, MSX2, MSY2, 15);
  ATPA := TPAToATPAEx(TPA, 30, 50); //TPAtoATPAEx!
  SortATPAFrom(ATPA, Point(MSCX, MSCY));//Sorting thru the ATPA
  DebugATPA(ATPA, '');
  for I := 0 to High(ATPA) do   //looping...
  begin
    MiddleTPAEx(ATPA[I], X, Y);
    If (X < 1) or (Y < 1) then // if our coords are greater than 1 means... idk
    begin
      Writeln('0');
      Continue;
    end;
    if (Y > MSCY) then
    begin
      Writeln('1');
      BBox :=  GetTPABounds(ATPA[I]);
      Width := (BBox.X2-BBox.X1);
      Height := (BBox.Y2-BBox.Y1);
      WriteLn('Width:'+ToStr(Width));
      WriteLn('Height:'+ToStr(Height));
      If (Width >= 22) and (Height >= 10) then
      begin
        Writeln('2');
        MMouse(X, Y, 6, 3);
        Wait(100+Random(50));  //always add a wait to wait for uptext
        if IsUpText('arrie') then
        begin
        GetMousePos(X, Y);
        Mouse(X, Y, 0, 0, True);
        FFlag(0);  //add fflag.
        Wait(400+Random(125));
        Result:=True;
        Makecompass('n');
        Exit;
        //ahhhh??
        end;
      end;
   end;
  end;
end;

function FindBlueBarrier: Boolean;//Needs some work. Sometimes finds the barrier sometimes doesnt. Gotta update some input.
var
  X, Y, I, Height, Width: Integer;//I dont know why i added'a' yet
  TPA : array of TPoint; //Same thing
  ATPA : T2DPointArray;
  bBox : TBox;

begin
  if not LoggedIn then Exit;
  //SetAngle(false);
  MakeCompass('e');
  FindColorsTolerance(TPA,13203298, MSX1, MSY1, MSX2, MSY2, 15);
  ATPA := TPAToATPAEx(TPA, 30, 50); //TPAtoATPAEx!
  SortATPAFrom(ATPA, Point(MSCX, MSCY));//Sorting thru the ATPA
  DebugATPA(ATPA, '');
  for I := 0 to High(ATPA) do   //looping...
  begin
    MiddleTPAEx(ATPA[I], X, Y);
    If (X < 1) or (Y < 1) then // if our coords are greater than 1 means... idk
    begin
      Writeln('0');
      Continue;
    end;
    if (Y < MSCY) then
    begin
      Writeln('1');
      BBox :=  GetTPABounds(ATPA[I]);
      Width := (BBox.X2-BBox.X1);
      Height := (BBox.Y2-BBox.Y1);
      WriteLn('Width:'+ToStr(Width));
      WriteLn('Height:'+ToStr(Height));
      If (Width >= 22) and (Height >= 10) then
      begin
        Writeln('2');
        MMouse(X, Y, 6, 3);
        Wait(100+Random(50));  //always add a wait to wait for uptext
        if IsUpText('arrie') then
        begin
        GetMousePos(X, Y);
        Mouse(X, Y, 0, 0, True);
        FFlag(0);  //add fflag.
        Wait(400+Random(125));
        Result:=True;
        Makecompass('n');
        Exit;
        //ahhhh??
        end;
      end;
   end;
  end;
end;



procedure STARTREDWAITINGROOM;
begin
end;

function GetRedWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, 2273738, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);

  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Lava width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Lava height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Lava TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetRedWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, 132331, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetRedWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToRedWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetRedWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance');
  TP := GetRedWaitingRoom;                   //IF RED DOOR IS COVER ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance : 2');
end;

function EnterRedWaitingRoom: Boolean;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('E');
  FindColorsTolerance(TPA, 5988801, 162, 68, 363, 218, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 2,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 40) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          if (ByPassWarning) then
          begin
            Result := True;
            FFlag(0);

            MakeCompass('N');
            SetAngle(0);
            Wait(1500 + Random(1500));
            if (Random(3) = 1) then
            begin
              Mouse(MSCX - 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end else
          begin
            if (Random(3) = 1) then
            begin
              Mouse(MSCX - 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;

procedure ENDREDWAITINGROOM;
begin
end;


function GameLoop: Boolean; //Gets repeated as long as we are in the game
begin
  if (InWaitingRoom) then
  begin
    InWaitingRoom2 := False;
    if (DetermineTeamToJoin = 'Red') then
    begin
      Walking(2501415, 12, Point(MMCX + 25, MMCY), 2, 2);
      FindRedBarrier;
    end else
    begin
      Walking(2501415, 12, Point(MMCX - 25, MMCY), 2, 2);
      FindBlueBarrier;
    end;
  end;
end;   //Lol i put this inbetween the two blank procedures to make the funciton list prettier


procedure STARTBLUEWAITINGROOM;
begin
end;

function GetBlueWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, 10391691, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);

  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Water width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Water height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Water TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetBlueWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, 132331, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetBlueWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToBlueWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetBlueWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance');
  TP := GetBlueWaitingRoom;                   //IF BLUE DOOR IS COVERed ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance : 2');
end;

function EnterBlueWaitingRoom: Boolean;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('W');
  FindColorsTolerance(TPA, 9203810, 162, 68, 363, 218, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 2,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 40) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          if (ByPassWarning) then
          begin
            Result := True;
            FFlag(0);

            MakeCompass('N');
            SetAngle(0);
            Wait(1500 + Random(1500));
            if (Random(3) = 1) then
            begin
              Mouse(MSCX + 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end else
          begin
            if (Random(3) = 1) then
            begin
              Mouse(MSCX + 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;

procedure ENDBLUEWAITINGROOM;
begin
end;

function GetGraveYardDoor : TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, 1271, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  SortATPAFrom(ATPA, Point(MMCY, MMCY));
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from graveyard door TPoint: '+ToStr(Distance(x, y, mmcx, MMCy)));
    if (Distance(x, y, MMCX, mmcy) < 33) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function GetLoc: String;
begin
  if (not(InGame)) then //If not in the game
  begin
    if (NearBank) then // If we are near the bank
    begin
      Result := 'LeaveBank';//Tell main loop to walk toward the middle of the two islands
      Exit;
    end else   // if we are not in game and not by bank
    begin
      if (InWaitingRoom) then // check if were in waiting room (Simple boolean)
      begin
        Result := 'Waiting Room';
        Exit;
      end;                  //if not, lets GOOO!
      Result := 'EnterWaitingRoom';
    end;
  end else
  begin
    Result := 'InGame';  //in game time
  end;

end;

begin
  SetupSRL;
  DeclarePlayers;
  ActivateClient;
  //countwallpixels;
  //terminatescript;

  repeat
    if (InGame) then
      Disguise('InGame');
    if (InWaitingRoom) then
      Disguise('InWaitingRoom');
    if (Random(2) = 1) then Debug(GetLoc);    //So the debug box doesnt get spammed
    case GetLoc of
      'LeaveBank':
      begin
        Walking(6713205, 15, Point(627, 146), 5, 5); // if Near the bank walk south to the middle of both boxes
      end;
      'EnterWaitingRoom':
      begin
        if (not(CompassNorth)) then // If your compass is east/west already from a previous attempt, then just try again
        begin
          if (DetermineTeamToJoin = 'Red') then
            if (EnterRedWaitingRoom) then
              Break;
          if (DetermineTeamToJoin = 'Blue') then
            if (EnterBlueWaitingRoom) then
              Break;
        end else
        begin
          if (DetermineTeamToJoin = 'Red') then
          begin
            if (WalkToRedWaitingEntrance) then  //Walks to the red
            begin
              EnterRedWaitingRoom;
            end;
          end;
          if (DetermineTeamToJoin = 'Blue') then
          begin
            if (WalkToBlueWaitingEntrance) then  //Walks to the blue
            begin
              EnterBlueWaitingRoom;
            end;
          end;
        end;
      end;
      'WaitingRoom':
      begin
        Wait(1250 + Random(1250));
        InWaitingRoom2 := True;
      end;
      'InGame':
      begin
        GameLoop;
      end;
    end;
  until False
end.
