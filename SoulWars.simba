program SW;
{$DEFINE SMART}
{$I SRL/SRL.simba}
{$I SRL/SRL/misc/debug.simba}
{Read: Debugging 9/10 time causes Simba to lose focus of Runescape. Right now a lot of the previous functions are acting up.
Colors need to be updated? To tired right now lol will continue working tomorrow.
Also if a player is covering the barrier in the graveyard our function screws up.
Some work to do but will figure it out. I'll continue learning and will reach our potential. }




const
  DebugScript = True;
  //Removed ur other const, cause its the same thing as this one
  Team = 'Random'; // Random, Last Won, Last Lost , Always Red, Always Blue,



const
  SW_ROADCOLOR    = 6846589 ; // Color of the roads out side of the game. (gray)
  SW_TREECOLOR    = 1071141 ; // Tree color outside of the game (Green)
  SW_WATERCOLOR   = 9932162 ; // Water surronding blue waiting room ( blue)
  SW_LAVACOLOR    = 1880011 ; // Lava surrounding the red waiting room (orange/yellowish)
  DOORCOLOR       = 67059   ; // Any door color (MM)
  MS_BARRIER_RED  = 5659569 ; // Barrier color of red team. MS
  MS_BARRIER_BLUE = 11234661; // Barrier color of blue team. MS
  WARNING_TEXT    = 2302945 ; // Chat box warning text when you go to join a game
  ARROW_MM_WHITE  = 13816788; // White arrow in game MM
  BLUE_NPC_MM     = 14519141; // Blue dots on MM
  WAITING_TEXT    = 39423   ; // Orange text to detect if we are in the waiting room



var
  TeamOn : String;
  RecentDead, InWaitingRoom2: Boolean;


procedure DeclarePlayers;
begin
  HowManyPlayers := 1; // Number of Players to use
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0; // Player to start with, first one is 0
  Players[0].Name := 'hi'; // Username
  Players[0].Pass := ''; // Password
  Players[0].Active := True; // True if you are using this player
  Players[0].Pin := ''; // Bank Pin. Leave it if you don't have one.
end;

procedure Debug(S: String);
begin
  if (DebugScript) then
    Writeln(s);
end;

Function CheckGameInSession: Boolean; //Text in  box telling you that a game is in session and if you want to continue regardless.
  begin
   {If FindText() then
   ChooseOption;}
  end;

Function CheckIsKicked: Boolean;  //To-be continued   Basically a chat box will appear telling you that you are banned from the game. Indicates time remaining.
begin
 {if FindText()}
end;


function InWaitingRoom: Boolean;
var
  I : Integer;
begin
  Result := GetColor(418, 33) = WAITING_TEXT; //Orange color in text
  if (not(Result)) then
  begin
    for I := 0 to 20 do
    begin
      Result := GetColor(418 + I, 33) = WAITING_TEXT; //Orange color in text
      if (Result) then Exit;
    end;
  end;

end;

function InGame : Boolean; //It doesn't matter which team your on to do this check btw, i showed u somewhere how simple it was to do this function  ;)
begin
  Result := GetColor(426, 144) = 39423;
end;


{function InGame: Boolean;  //To-be heavily optimized. I know, I know it looks really ugly. Sorry bare with me. However the colors should work. Tested througly.
  var
  x,y,CTS: Integer;
begin
  CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
    If  (Lowercase(Team) = 'red') then
    begin
      SetColorSpeed2Modifiers(0.73, 1.56);
    if  FindColorSpiralTolerance(x, y, 1118245, MSX1, MSY1, MSX2, MSY2, 1) then
    begin
      writeln('Found Red team');
        ColorToleranceSpeed(CTS);
          SetColorSpeed2Modifiers(0.2, 0.2);
            Result:= True;
            end;
end else
    if (Lowercase(Team) = 'blue') then
     CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(0.43, 7.28);
    if FindColorSpiralTolerance(X, Y, 2562576, MSX1, MSY1, MSX2, MSY2, 1) then
     writeln('Found Blue Team');
        ColorToleranceSpeed(CTS);
          SetColorSpeed2Modifiers(0.2, 0.2);
            Result:= True;
     end;
}


function DetermineTeamToJoin: String;
begin  //Red or Blue
  if (TeamOn = '') then
  begin
    if (Team = 'Random') then
    begin
      if (Random(2) = 1) then
        Result := 'Blue'
      else
        Result := 'Red';
    end;
    TeamOn := Result;
  end else
  begin
    Result := TeamOn;
  end;
  Debug('Team : '+ToStr(Result)+'');
end;

function CompassNorth : Boolean;//gets the compass and checks if ur facing north
var
  C : Integer;
begin
  C := Round(RS_GetCompassAngleDegrees);
  if ((InRange(c, 340, 360)) or (InRange(c, 0, 20)))then
    Result := True;
end;


function NearBank : Boolean;
var
  TPA : TPointArray;
begin
  if not LoggedIn then Exit;

  if (not(CompassNorth)) then
    Exit;
  if (InWaitingRoom) then Exit;
  FindColorsTolerance(TPA, SW_TREECOLOR, 605, 12, 664, 39, 15);//Box on northern part of MM(alot of trees)
  Debug('Length of MM Trees TPA: '+ToStr(Length(TPA))+'');
  if (Length(TPA) > 680) then
  begin
    Result := True;
    Debug('Player: Near Bank'); //looks for the trees (if u stand by bank u see them north of u) looks for those
  end;
end;



function GetGraveYardDoor : TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 2);
  SortATPAFrom(ATPA, Point(MMCY, MMCY));
  DebugATPA(ATPA, '');
  for A := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from graveyard door TPoint: '+ToStr(Distance(x, y, mmcx, MMCy)));
    if (Distance(x, y, MMCX, mmcy) < 35) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
     // if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 2) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function InGraveYard : Boolean;
var
  I, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  TB : TBox;
  TP: TPoint;
begin
  if not LoggedIn then Exit;

  if (InWaitingRoom) then Exit;
  if (not(InGame)) then Exit;
  if (not(CompassNorth)) then
    MakeCompass('n');
  FindColorsTolerance(TPA, 15987435, MMCX - 60, MMCY - 65, MMCX + 60, MMCY + 65, 25);
  Debug('Length of walls TPA: '+ToStr(Length(TPA))+'');
  ATPA := TPAToATPAEx(TPA, 35, 55);
  DebugATPA(ATPA, '');
  writeln('Length of potential graveyards: '+ToStr(Length(ATPA))+'');
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[i], x, y);
    TB := GetTPABounds(ATPA[i]);
    debug('walls = '+tostr(tb.x2 - tb.x1)+ ', '+tostr(tb.y2- tb.y1)+'');
    if ((tb.x2 - tb.x1) > 20) and ((tb.y2 - tb.y1) > 35) then
    begin
      if (PointInBox(Point(MMCX, MMCY), TB)) then   //MMCX , MMCY
      begin
        Debug('Maybe In Graveyard');
        TP := GetGraveYardDoor;
        if (DetermineTeamToJoin = 'Blue') then
        begin
          if (MMCX > TP.X) then
          begin
            Result := True;
            Debug('In Graveyard');
            Exit;
          end;
        end;
        if (DetermineTeamToJoin = 'Red') then
        begin
          if (MMCX < TP.X) then
          begin
            Result := True;
            Debug('In Graveyard');
            Exit;
          end;
        end;
      end;
    end;
    Wait(25);
  end;
end;


function ClickWhiteArrowMM: Boolean; //

var
  A, X, Y, Width, Height : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  MakeCompass('N');      //Has to be N or else you get some weird results at times.
  FindColorsTolerance(TPA, ARROW_MM_WHITE , MMX1, MMY1, MMX2, MMY2, 20); //Small box around area of arrow
  ATPA := TPAToATPAEx(TPA, 3,3);//split the big tpa into small boxs
  SortATPAFrom(ATPA, Point(MMCX, MMCY)); //
  for A := High(ATPA) downto 0 do //Sort from FARTHEST away ;)
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from arrow MM: '+ToStr(Distance(x, y, MMCX, MMCy)));
    bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
    Debug('ARROW Mm width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('ARROW Mm height: '+ToStr(bBox.y2 - bBox.y1)+'');
    Width := (BBox.X2-BBox.X1);
    Height := (BBox.Y2-BBox.Y1);
    //HINT: for starting purposes, make sure the arrow is atleast 60 pixels away from MMCX , MMCY
    //then check width/height
    If (Distance(X, Y, MMCX, MMCY) >= 60) then //atleast 60 Pixels away...
    begin
      Writeln('Arrow is 60 pixels away');
      If (Width <= 4) and (Height <= 3) and (Width >= 1) and (Height >= 1) then //Checks to see if TPA matches the info we got from the debug.
      begin
        WriteLn('Found White Arrow');
        Mouse(X, Y, 7, 7, True);      //Just to see if it works. It works, but if Red Arrow is covering, the TPA is still found,
        Wait(500 + Random(500));
        FFlag(0);
        Wait(500 + Random(500));
        Result := True;
        Exit;
      end;                   //But the color is lost.
    end;
  end;
end;

function RotatePointEx(p, o:tPoint; d:Extended):TPoint ;
begin
  p.x := p.x + (0 - o.x);
  p.y := p.y + (0 - o.y);

  Result.x := (round(p.x * cos(d * (PI / 180)) -  (p.y * sin(d * (PI / 180))))) - o.x * -1;
  Result.y := (round(sin(d * (PI / 180)) * p.x + cos(d * 1 * (PI / 180)) * p.y)) - o.y * -1;
end;

function Walking(Color, Tolerance: Integer; SortFrom: TPoint; RX, RY: Integer): Boolean;
var
  i, x, y, a : Integer;
  TPA: TPointArray;
  xT : TPoint;
begin
  if not LoggedIn then Exit;
  FindNormalRandoms;
  a := round(RS_GetCompassAngleDegrees);
  a := (360 - a);
  xT := RotatePointEx(SortFrom, Point(MMCX,MMCY), a);
  FindColorsSpiralTolerance(MMCX, MMCY, TPA, Color, MMX1, MMY1, MMX2, MMY2, Tolerance);
  if (Length(TPA) < 10) then Exit;

  SortTPAFrom(TPA, XT);

  for i := 0 to High(TPA) do
  begin
    x := TPA[i].x;
    y := TPA[i].y;

    rx := RandomRange(-rx, rx);
    ry := RandomRange(-ry, ry);
    if (not rs_OnMinimap(x + rx, y + ry)) then
      Continue;

    Mouse(x + rx, y + ry, 0, 0, true);
    FFlag(0);
    Wait(700 + Random(500));
    Result := True;
    Break;
  end;
end;

function ByPassWarning : Boolean;
var I : Integer;
begin
  if FindNPCChatText('inutes', Nothing) then
  begin
    Debug('Waiting a minute to wait for this warning to leave');
    Wait(55000 + Random(10000));
    MMouse(Random(500), Random(500), 0, 0);
    Mouse(260, 470, 14, 4, True);
    Exit;
  end;
  for I := 0 to 30 do
  begin
    if (GetColor(41 + I, 406 + Random(3)) = WARNING_TEXT) then
    begin
      Mouse(260, 470, 15, 4, True);
      Wait(1250 + Random(1500));
      Mouse(258, 408, 15, 4, True);
      Wait(1250 + Random(1500));
      Result := True;
    end;
  end;
  Result := True;
end;




function FindRedBarrier(x1, y1, x2, y2: Integer): Boolean; //continues to work all right

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, MS_BARRIER_RED, x1, y1, x2, y2, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 2,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 120) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          Result := True;
          SetAngle(0);
          MakeCompass('n');
          InWaitingRoom2 := False;
          Exit;
        end;
      end;
    end;
    wait(10);
  end;
end;

function FindBlueBarrier(x1, y1, x2, y2: Integer): Boolean;//Needs some work. Sometimes finds the barrier sometimes doesnt. Gotta update some input.
var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('e');
  FindColorsTolerance(TPA, MS_BARRIER_BLUE, x1, y1, x2, y2, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 2,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from blue grave door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 40) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Blue Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Blue Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          Result := True;
          SetAngle(0);
          MakeCompass('n');
          InWaitingRoom2 := False;
          Exit;
        end;
      end;
    end;
    wait(10);
  end;
end;



procedure STARTREDWAITINGROOM;
begin
end;

function GetRedWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, SW_LAVACOLOR, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);

  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Lava width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Lava height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Lava TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetRedWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetRedWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToRedWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetRedWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance');
  TP := GetRedWaitingRoom;                   //IF RED DOOR IS COVER ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance : 2');
end;

function EnterRedWaitingRoom: Boolean;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('E');
  FindColorsTolerance(TPA, MS_BARRIER_RED, 162, 68, 363, 218, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 2,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 40) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          if (ByPassWarning) then
          begin
            Result := True;
            FFlag(0);

            MakeCompass('N');
            SetAngle(0);
            Wait(1500 + Random(1500));
            if (Random(3) = 1) then
            begin
              Mouse(MSCX + 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end else
          begin
            if (Random(3) = 1) then
            begin
              Mouse(MSCX + 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;

procedure ENDREDWAITINGROOM;
begin
end;


function GetNpcsATPA: TpointArray;
var
  TPA: TPointArray;


begin
 //if not (LoggedIn) then Exit;
 FindColorsTolerance(TPA, BLUE_NPC_MM, MMX1, MMY1, MMX2, MMY2, 20);
 Result := TPA;
end;

function LeaveCrowdedGrave: Boolean;
var
  TPA, TPA2: TPointArray;
  ATPA: T2DPointArray;
  I, X, Y, R : Integer;
begin
  TPA := GetNPCSATPA;
  writeln(length(tpa));
  ATPA := SplitTPA(TPA, 10);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[i], X, Y);
    if (Distance(X, Y, MMCX, MMCY) < 25) then
    begin
      if (DetermineTeamToJoin = 'Blue') then
        R := -6
      else
        R := 6;
      Mouse(X + R, Y + R, 3, 3, True);
      FFlag(0);
      Wait(500 + Random(500));
      SetAngle(1);
      if (DetermineTeamToJoin = 'Blue') then
      begin
        MakeCompass('e')
        if (FindBlueBarrier(MSX1, MSY1, MSX2, MSY2)) then
        begin
          SetAngle(0);
          MakeCompass('n');
          Result := True;
          Exit;
        end;
      end else
      begin
        MakeCompass('w');
        if (FindRedBarrier(MSX1, MSY1, MSX2, MSY2)) then
        begin
          SetAngle(0);
          MakeCompass('n');
          Result := True;
          Exit;
        end;
      end;
      SetAngle(0);
      MakeCompass('n');
    end;
  end;
end;



function GameLoop: Boolean; //Gets repeated as long as we are in the game
var
  TP : TPoint;

begin
  if not (InGame) then Exit;

  Result := True;
  if (HPPercent < 1) then
  begin
    while (HPPercent < 1)  do
    begin
      if not LoggedIn then Exit;
      Wait(250 + Random(250));
    end;

    Wait(2500 + Random(2500));
    repeat
      Writeln('Searching for barrier, found dead');
      SetAngle(1);

      if (DetermineTeamToJoin = 'Blue') then
      begin
        if (FindBlueBarrier(MSX1, MSY1, MSX2, MSY2)) then
           Break;
        MakeCompass('e');
      end else
      begin
        if (FindRedBarrier(MSX1, MSY1, MSX2, MSY2)) then
          Break;
        MakeCompass('w');
      end;
      LeaveCrowdedGrave;
      Wait(250 + Random(250));
    until (not(InGame)) or not (LoggedIn)
    SetAngle(0);
    MakeCompass('n');
  end;
  if (InWaitingRoom2) then
  begin
    TP := GetGraveYardDoor;
    if (TP.X > 0) then
    begin
      if (DetermineTeamToJoin = 'Blue') then
      begin
        Mouse(TP.X + 1, TP.Y + 5, 2, 1, True) ;
        SetAngle(1);
        MakeCompass('e');
      end else
      begin
        Mouse(TP.X + 1, TP.Y -5, 2, 1, True);
        SetAngle(1);
        MakeCompass('w');
      end;

      Wait(750 + Random(640));
      FFlag(0);
      if (DetermineTeamToJoin = 'Red') then
        FindRedBarrier(MSX1, MSY1, MSX2, MSY2)
      else
        FindBlueBarrier(MSX1, MSY1, MSX2, MSY2);
    end;
    Debug('Backup leave method');
    LeaveCrowdedGrave;
  end else
  begin
    if (not(ClickWhiteArrowMM)) then
      Writeln('Fight');
  end;
end;


procedure STARTBLUEWAITINGROOM;
begin
end;

function GetBlueWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, SW_WATERCOLOR, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);

  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Water width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Water height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Water TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetBlueWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetBlueWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToBlueWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetBlueWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance');
  TP := GetBlueWaitingRoom;                   //IF BLUE DOOR IS COVERed ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance : 2');
end;

function EnterBlueWaitingRoom: Boolean;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  SetAngle(1);
  MakeCompass('W');
  FindColorsTolerance(TPA, MS_BARRIER_BLUE, 162, 68, 363, 218, 30); //Small box around area of portal
  ATPA := TPAToATPAEx(TPA, 2,3);//split the big tpa into small boxs
  SortATPASize(ATPA, True); //sort by the bigger boxes first
  SortATPAFrom(ATPA, Point(MSCX, MSCY)); //and the ones closest to us
  DebugATPA(ATPA, '');     //..
  for A := 0 to High(ATPA) do //its late, idont remember why im going down from the top
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water door: '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < 40) then  //if we are close to barrier
    begin
      bBox := GetTPABounds(ATPA[A]);   //get a TBOX of the atpa
      Debug('Door MS width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door MS height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 2) and (bBox.Y2 - bBox.Y1 >= 2) then  //if its this big
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Mouse(X, Y, 6, 6, False);   //goo!!!!!!
        if (WaitOption('arrier', 1500)) then
        begin
          FFlag(0);
          Wait(1500 + Random(2000));
          if (ByPassWarning) then
          begin
            Result := True;
            FFlag(0);

            MakeCompass('N');
            SetAngle(0);
            Wait(1500 + Random(1500));
            if (Random(3) = 1) then
            begin
              Mouse(MSCX - 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));

            end;
            Exit;
          end else
          begin
            if (Random(3) = 1) then
            begin
              Mouse(MSCX - 100, MSCY, 40, 40, True);
              FFlag(0);
              Wait(1500 + Random(1500));
            end;
            Exit;
          end;
        end;
      end;
    end;
    wait(10);
  end;
end;

procedure ENDBLUEWAITINGROOM;
begin
end;

function GetLoc: String;
begin
  if (not(InGame)) then //If not in the game
  begin
    if (NearBank) then // If we are near the bank
    begin
      Result := 'LeaveBank';//Tell main loop to walk toward the middle of the two islands
      Exit;
    end else   // if we are not in game and not by bank
    begin
      if (InWaitingRoom) then // check if were in waiting room (Simple boolean)
      begin
        Result := 'Waiting Room';
        InWaitingRoom2 := True;
        Exit;
      end;                  //if not, lets GOOO!
      Result := 'EnterWaitingRoom';
    end;
  end else
  begin
    Result := 'InGame';  //in game time
  end;

end;

begin
  Smart_Server := 44;
  Smart_Members := True;
  Smart_Signed := True;
  Smart_SuperDetail := False;
  SetupSRL;
  DeclarePlayers;
  ActivateClient;
  Mouse(88, 493, 8, 8, True);//Set chat -> Game
  TeamOn := 'Red'; //for now just set this...
  inwaitingroom2 := true;   //leave this to true if ur starting in the aiting room or ion the graveyard

  //leavecrowdedgrave;
 // terminatescript;
  repeat
    if (InGame) then
    begin
      Disguise('InGame');
    end;
    if (InWaitingRoom) then
      Disguise('InWaitingRoom');
    //if (Random(2) = 1) then Debug(GetLoc);    //So the debug box doesnt get spammed
    case GetLoc of
      'LeaveBank':
      begin
        Walking(6713205, 15, Point(627, 146), 5, 5); // if Near the bank walk south to the middle of both boxes
      end;
      'EnterWaitingRoom':
      begin
        if (not(CompassNorth)) then // If your compass is east/west already from a previous attempt, then just try again
        begin
          if (DetermineTeamToJoin = 'Red') then
            EnterRedWaitingRoom;
          if (DetermineTeamToJoin = 'Blue') then
            EnterBlueWaitingRoom;

        end else
        begin
          if (DetermineTeamToJoin = 'Red') then
          begin
            if (WalkToRedWaitingEntrance) then  //Walks to the red
            begin
              EnterRedWaitingRoom;
            end;
          end;
          if (DetermineTeamToJoin = 'Blue') then
          begin
            if (WalkToBlueWaitingEntrance) then  //Walks to the blue
            begin
              EnterBlueWaitingRoom;
            end;
          end;
        end;
      end;
      'WaitingRoom':
      begin
        InWaitingRoom2 := True;
        Wait(1250 + Random(1250));
      end;
      'InGame':
      begin
        GameLoop;
      end;
    end;
  until False
end.
