program SW;
{$DEFINE SMART}
{$I SRL/SRL.simba}
{$i sps/sps.simba}
{$I SRL/SRL/misc/debug.simba}
{Read: Debugging 9/10 time causes Simba to lose focus of Runescape. Right now a lot of the previous functions are acting up.
Colors need to be updated? To tired right now lol will continue working tomorrow.
Also if a player is covering the barrier in the graveyard our function screws up.
Some work to do but will figure it out. I'll continue learning and will reach our potential. }




const
  DebugScript = True;
  //Removed ur other const, cause its the same thing as this one
  Team = 'Random'; // Random, Last Won, Last Lost , Always Red, Always Blue,



const
  SW_ROADCOLOR    = 6846589 ; // Color of the roads out side of the game. (gray)
  SW_TREECOLOR    = 1071141 ; // Tree color outside of the game (Green)
  SW_WATERCOLOR   = 9932162 ; // Water surronding blue waiting room ( blue)
  SW_LAVACOLOR    = 1880011 ; // Lava surrounding the red waiting room (orange/yellowish)
  DOORCOLOR       = 67059   ; // Any door color (MM)
  MS_BARRIER_RED  = 5659569 ; // Barrier color of red team. MS
  MS_BARRIER_BLUE = 11234661; // Barrier color of blue team. MS
  WARNING_TEXT    = 2302945 ; // Chat box warning text when you go to join a game
  ARROW_MM_WHITE  = 15790834; // White arrow in game MM
  ARROW_MM_BLUE   = 16745299; // blue arrow in game MM
  ARROW_MM_RED    = 7901    ; // reed arrow in game MM
  BLUE_NPC_MM     = 14519141; // Blue dots on MM
  NPC_MM          = 193785  ; // Yellow dots;
  WHITE_DOTS      = 15397352; // White dots
  WAITING_TEXT    = 39423   ; // Orange text to detect if we are in the waiting room
  LARGE_GRAVE_WALL= 15854326; // Wall MM of large grave.
  SMALL_GRAVE_WALL= 15527151; // Wall MM of small grave.
  BLUE_CAPE       = 3416080 ; // blue teams cape
  RED_CAPE        = 1249591 ; // Red Teams cape

var
  TeamOn : String;
  InWaitingRoom2: Boolean;



procedure DeclarePlayers;
begin
  HowManyPlayers := 1; // Number of Players to use
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0; // Player to start with, first one is 0
  Players[0].Name := 'hi'; // Username
  Players[0].Pass := ''; // Password
  Players[0].Active := True; // True if you are using this player
  Players[0].Pin := ''; // Bank Pin. Leave it if you don't have one.
end;

procedure Debug(S: String);
begin
  if (DebugScript) then
    Writeln(s);
end;

function InWaitingRoom: Boolean;
var
  I : Integer;
begin
  Result := GetColor(418, 33) = WAITING_TEXT; //Orange color in text
  if (not(Result)) then
  begin
    for I := 0 to 20 do
    begin
      Result := GetColor(418 + I, 33) = WAITING_TEXT; //Orange color in text
      if (Result) then Exit;
    end;
  end;

end;


function InGame : Boolean; //It doesn't matter which team your on to do this check btw, i showed u somewhere how simple it was to do this function  ;)
begin
  Result := GetColor(426, 144) = 39423;
end;


Function FindGraveYardColor : Integer;
var
  TPA : TPointArray;
  arC : TIntegerArray;
  CTS, I,v,w: Integer;
  R, G, B, arL : Integer;
  X, Y, Z : Extended;

begin
  CTS := GetColorToleranceSpeed;
  ColorToleranceSpeed(2);
  SetColorSpeed2Modifiers(25.28, 25.37);
  FindColorsSpiralTolerance(v, w, TPA, 16050923, MMX1, MMY1, MMX2, MMY2, 6);
    If (Length(TPA) = 0) then
    begin
     writeln('Failed To Find Color');
     ColorToleranceSpeed(CTS);
     SetColorSpeed2Modifiers(0.2, 0.2);
     Exit;
    end;
  arC := GetColors(TPA);
  ClearSameIntegers(arC);
  arL := High(arC);

  for i := 0 to arL do
  begin
    ColorToRGB(arC[i], R, G, B);
    writeln('r = '+tostr(r)+', g = '+tostr(g)+', b = '+tostr(b)+'');
    if (R >= 232) and (R <= 240) and (G >= 231) and (G <= 246) and (B >= 237) and (B <= 259) then
    begin
      ColorToXYZ(arC[i], X, Y, Z);
      writeln('x = '+tostr(x)+', y = '+tostr(y)+', z = '+tostr(z)+'');
      if (X >= 80.04) and (X <= 83.50) and (Y >= 82.13) and (Y <= 88.94) and (Z >= 92.99) and (Z <= 108.44) then
       begin
          Result := arC[i];
          Writeln('AutoColor = ' + IntToStr(arC[i]));
          Break;
       end;
    end;
  end;
end;

function DetermineTeamToJoin: String;
begin  //Red or Blue
  if (TeamOn = '') then
  begin
    if (Team = 'Random') then
    begin
      if (Random(2) = 1) then
        Result := 'Blue'
      else
        Result := 'Red';
    end;
    TeamOn := Result;
  end else
  begin
    Result := TeamOn;
  end;
 // Debug('Team : '+ToStr(Result)+'');
end;

function FindCustomTPA(Name, Compass: String; Angle, Color, X1, Y1, X2, Y2, Tolerance, Width, Height, SplitMethod, SortMethod: Integer; DebugBound: Boolean; DistanceCheck, MinWidth, MinHeight: Integer; Right: Boolean; UpText, Option: String): Boolean;
var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if (not(LoggedIn)) then Exit;
  SetAngle(Angle);
  MakeCompass(Compass);
  FindColorsTolerance(TPA, Color, x1, y1, x2, y2, Tolerance);
  case SplitMethod of
    1:  ATPA := TPAToATPAEx(TPA, Width, Height);
    2:  ATPA := SplitTPAEx(TPA, Width, Height);
  end;
  if (Length(ATPA) < 1) then
  begin
    Debug('WARNING - ATPA['+name+']:  < 1 CHECK SPLIT METHOD');
    Exit;
  end;
  case SortMethod of
    1: SortATPASize(ATPA, True);
    2: SortATPASize(ATPA, False);
    3: SortATPAFrom(ATPA, Point(MSCX, MSCY));
  end;
  if (DebugBound) then
    DebugATPABounds(ATPA);
  for A := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    if (InGame) then
      if (Y < MSCY) then
        Continue;
    Debug('Distance from '+Name+': '+ToStr(Distance(x, y, MSCX, MSCY)));
    if ((Distance(x, y, MSCX, MSCY)) < DistanceCheck) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug(name+': width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug(name+': height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= MinWidth) and (bBox.Y2 - bBox.Y1 >= MinHeight) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        if (Right) then
        begin
          Mouse(X, Y, 6, 6, False);
          if (WaitOption(Option, 250)) then
          begin
            FFlag(0);
            Result := True;
            MakeCompass('N');
            SetAngle(SRL_ANGLE_HIGH);
            Exit;
          end;
        end else
        begin
          MMouse(X,Y, 6, 6);
          if (WaitUpText(UpText, 250)) then
          begin
            GetMousePos(X, Y);
            Mouse(X, Y, 0, 0, True);
            FFlag(0);
            Result := True;
            MakeCompass('N');
            SetAngle(SRL_ANGLE_HIGH);
            Exit;
          end;
        end;
      end;
    end;
  end;
  MakeCompass('N');
  SetAngle(SRL_ANGLE_HIGH);
end;

function CompassNorth : Boolean;//gets the compass and checks if ur facing north
var
  C : Integer;
begin
  C := Round(RS_GetCompassAngleDegrees);
  if ((InRange(c, 354, 360)) or (InRange(c, 0, 13)))then
    Result := True;
end;


function NearBank : Boolean;
var
  TPA : TPointArray;
begin
  if not LoggedIn then Exit;

  if (not(CompassNorth)) then
    Exit;
  if (InWaitingRoom) then Exit;
  FindColorsTolerance(TPA, SW_TREECOLOR, 605, 12, 664, 39, 15);//Box on northern part of MM(alot of trees)
  Debug('Length of MM Trees TPA: '+ToStr(Length(TPA))+'');
  if (Length(TPA) > 680) then
  begin
    Result := True;
    Debug('Player: Near Bank'); //looks for the trees (if u stand by bank u see them north of u) looks for those
  end;
end;



function GetGraveYardDoor : TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  Result := Point(-1, -1);
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 2);
  SortATPAFrom(ATPA, Point(MMCY, MMCY));
  DebugATPA(ATPA, '');
  for A := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from graveyard door TPoint: '+ToStr(Distance(x, y, mmcx, MMCy)));
    if (Distance(x, y, MMCX, mmcy) < 35) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 <=  2) and (bBox.Y2 - bBox.Y1 <= 2) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;


function SameArrowTP: Tpoint;

var
  A, X, Y, Width, Height : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  if (not(CompassNorth)) then
  MakeCompass('N');
  if (DetermineTeamToJoin = 'Red') then
    FindColorsTolerance(TPA, ARROW_MM_Red , MMX1, MMY1, MMX2, MMY2, 20)
  else
    FindColorsTolerance(TPA, ARROW_MM_BLUE , MMX1, MMY1, MMX2, MMY2, 20);
  ATPA := TPAToATPAEx(TPA, 4,4);
  SortATPAFrom(ATPA, Point(MMCX, MMCY));
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from arrow MM: '+ToStr(Distance(x, y, MMCX, MMCy)));
    bBox := GetTPABounds(ATPA[A]);
    Debug('ARROW Mm width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('ARROW Mm height: '+ToStr(bBox.y2 - bBox.y1)+'');
    Width := (BBox.X2-BBox.X1);
    Height := (BBox.Y2-BBox.Y1);

    If (Distance(X, Y, MMCX, MMCY) >= 40) then
    begin
      If (Width <= 5) and (Height <= 5) and (Width >= 1) and (Height >= 1) then
      begin
        Debug('Found Arrow');
        Result := Point(x,y);
        Exit;
      end;
    end;
  end;
end;

function RotatePointEx(p, o:tPoint; d:Extended):TPoint ;
begin
  p.x := p.x + (0 - o.x);
  p.y := p.y + (0 - o.y);

  Result.x := (round(p.x * cos(d * (PI / 180)) -  (p.y * sin(d * (PI / 180))))) - o.x * -1;
  Result.y := (round(sin(d * (PI / 180)) * p.x + cos(d * 1 * (PI / 180)) * p.y)) - o.y * -1;
end;

function Walking(Color, Tolerance: Integer; SortFrom: TPoint; RX, RY: Integer): Boolean;
var
  i, x, y, a : Integer;
  TPA: TPointArray;
  xT : TPoint;
begin
  if not LoggedIn then Exit;
  FindNormalRandoms;
  a := round(RS_GetCompassAngleDegrees);
  a := (360 - a);
  xT := RotatePointEx(SortFrom, Point(MMCX,MMCY), a);
  FindColorsSpiralTolerance(MMCX, MMCY, TPA, Color, MMX1, MMY1, MMX2, MMY2, Tolerance);
  if (Length(TPA) < 10) then Exit;

  SortTPAFrom(TPA, XT);

  for i := 0 to High(TPA) do
  begin
    x := TPA[i].x;
    y := TPA[i].y;

    rx := RandomRange(-rx, rx);
    ry := RandomRange(-ry, ry);
    if (not rs_OnMinimap(x + rx, y + ry)) then
      Continue;

    Mouse(x + rx, y + ry, 0, 0, true);
    FFlag(0);
    Wait(700 + Random(500));
    Result := True;
    Break;
  end;
end;

function ByPassWarning : Boolean;
var I : Integer;
begin
  if FindNPCChatText('inutes', Nothing) then
  begin
    Debug('Waiting a minute to wait for this warning to leave');
    Wait(55000 + Random(10000));
    MMouse(Random(500), Random(500), 0, 0);
    Mouse(260, 470, 14, 4, True);
    Exit;
  end;
  for I := 0 to 30 do
  begin
    if (GetColor(41 + I, 406 + Random(3)) = WARNING_TEXT) then
    begin
      Mouse(260, 470, 15, 4, True);
      Wait(1250 + Random(1500));
      Mouse(258, 408, 15, 4, True);
      Wait(1250 + Random(1500));
      Result := True;
    end;
  end;
  Result := True;
end;


procedure STARTREDWAITINGROOM;
begin
end;

function GetRedWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, SW_LAVACOLOR, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);
  DebugATPA(atpa, '');
  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Lava width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Lava height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Lava TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetRedWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetRedWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from lava TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToRedWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  TP := GetRedWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance');
  TP := GetRedWaitingRoom;                   //IF RED DOOR IS COVER ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to red entrance : 2');
end;

function EnterRedWaitingRoom: Boolean;
begin
  if (InWaitingRoom) Then Exit;
  if InGame then Exit;
  if (FindCustomTPA('RedWaitingRoom', 'E', SRL_ANGLE_LOW, MS_BARRIER_RED, 162, 68, 363, 218, 30, 3, 3, 1, 3, True, 65, 2, 2, True, 'arrier', 'arrier')) then
  begin
    if (ByPassWarning) then
    begin
      Result := True;
      FFlag(0);

      Wait(1500 + Random(1500));
      if (Random(3) = 1) then
      begin
        Mouse(MSCX + 150, MSCY, 40, 40, True);
        FFlag(0);
        Wait(1500 + Random(1500));
      end;
      Exit;
    end else
    begin
      if (Random(3) = 1) then
      begin
        Mouse(MSCX + 100, MSCY, 40, 40, True);
        FFlag(0);
        Wait(1500 + Random(1500));
      end;
      Exit;
    end;
  end;
end;

procedure ENDREDWAITINGROOM;
begin
end;

function InMiddleArea: Boolean;
var
  Box: TBox;
  TP : TPoint;
begin
  TP := SPS_GetMyPos;
  Box := PointToBox(Point(611, 4987), Point(721, 5062));
  Result:= PointInBox(TP, Box);
end;

function InLargeGrave: Boolean;
var
  Box: TBox;
  TP: TPoint;
begin
  TP := SPS_GetMyPos;
  if (DetermineTeamToJoin = 'Blue') then
  begin
    Box := PointToBox(Point(385, 5035), Point(415, 5075));
    Result := PointInBox(TP, Box);
  end else
  begin
    Box := PointToBox(Point(921, 4974), Point(955, 5018));
    Result := PointInBox(TP, Box);
  end;
end;

function InSmallGrave: Boolean;
var
  Box: TBox;
  TP: TPoint;
begin
  TP := SPS_GetMyPos;

  Box := PointToBox(Point(483, 5075), Point(494, 5088));
  Result := PointInBox(TP, Box);

  if (Result) then Exit;

  Box := PointToBox(Point(846, 4965), Point(860, 4981));
  Result := PointInBox(TP, Box);

end;

function FindBlueBarrier: Boolean;
begin
  if (InWaitingRoom) Then Exit;
  if (not(InGame)) then Exit;
  if (InLargeGrave) then
  begin
    if (FindCustomTPA('BlueBarrier', 'E', SRL_ANGLE_LOW, MS_BARRIER_BLUE, MSX1, MSY1, MSX2, MSY2, 30, 3, 3, 1, 3, True, 365, 2, 2, True, 'arrier', 'arrier')) then
    begin
      Result := True;
      Exit;
    end;
  end else
  begin
    if (InSmallGrave) then
      if (FindCustomTPA('BlueBarrier', 'S', SRL_ANGLE_LOW, MS_BARRIER_BLUE, MSX1, MSY1, MSX2, MSY2, 30, 3, 3, 1, 3, True, 365, 2, 2, True, 'arrier', 'arrier')) then
      begin
        Result := True;
        Exit;
      end;
  end;
end;

function AttackPlayer : Boolean;
var
  TPA: TPointArray;
  ATPA: T2DPointArray;
  X, Y, I: Integer;
begin
  if (DetermineTeamToJoin = 'Red') then

    FindColorsTolerance(TPA, BLUE_CAPE, 9, 66, 494, 323, 8)
  else
    FindColorsTolerance(TPA, RED_CAPE, 9, 66, 494, 323, 8);

  ATPA := TPAToATPAEx(TPA, 7, 7);
  SortATPAFrom(ATPA, Point(MSCX, MSCY));
  for I := 0 to High(ATPA) do
  begin
    MiddleTPAEx(ATPA[i], x, y);
    if (PointInBox(Point(x, y), IntToBox(233, 137, 284, 193))) then //if the point is our character
      Continue;
    if (PointInBox(Point(x, y), IntToBox(240, 24, 390, 85))) then //grave yard control
      Continue;
    if (PointInBox(Point(x, y), IntToBox(391, 22, 502, 175))) then//Activity bar and shit near that
      Continue;

    Mouse(X, Y, 7, 7, False);
    if WaitOption('ttack', 250) then
    begin
      FFlag(0);
      Result := True;
      Exit;
    end;
    Wait(500);


  end;

end;

function FindRedBarrier: Boolean;
begin
  if (InWaitingRoom) Then Exit;
  if (not(InGame)) then Exit;
  if (InLargeGrave) then
  begin
    if (FindCustomTPA('RedBarrier', 'W', SRL_ANGLE_LOW, MS_BARRIER_RED, MSX1, MSY1, MSX2, MSY2, 30, 3, 3, 1, 3, True, 365, 2, 2, True, 'arrier', 'arrier')) then
    begin
      Result := True;
      Exit;
    end;
  end else
  begin
    if (InSmallGrave) then
    if (FindCustomTPA('RedBarrier', 'N', SRL_ANGLE_LOW, MS_BARRIER_RED, MSX1, MSY1, MSX2, MSY2, 30, 3, 3, 1, 3, True, 365, 2, 2, True, 'arrier', 'arrier')) then
    begin
      Result := True;
      Exit;
    end;
  end;
end;

function ClickWhiteArrow: Boolean;
var
  BMP : Integer;
  X, Y, I: Integer;
begin
  Bmp := BitmapFromString(6, 5, 'meJz78OnTByT05///D1QSAQAxklWX');
  for I := 0 to 10 do
  begin
    if (FindBitmapToleranceIn(bmp, X, Y, MMX1, MMY1, MMX2, MMY2, 5)) then
    begin
      Mouse(x, y, 7, 7, True);
      FFlag(10);
      Result := True;
      FreeBitmap(bmp);
      Exit;
    end;
    Wait(375 + Random(375));
  end;
  FreeBitmap(bmp);
end;


function GameLoop: Boolean; //Gets repeated as long as we are in the game
var
   FS: Integer;
begin
  if not (InGame) then Exit;
  Result := True;
  if (InSmallGrave) then
  begin
    repeat
      if (DetermineTeamToJoin = 'Red') then
      begin
        if (FindRedBarrier) then
        begin
          Mouse(572, 118, 6, 6, True);
          FFlag(0);
          Exit;
        end;
      end else
      begin
        if (FindBlueBarrier) then
        begin
          Mouse(670, 47, 6, 6, True);
          FFlag(0);
          Exit;
        end;
      end;
      Wait(500 + Random(1500));
    until (not(InGame)) or (not(InSmallGrave)) or (not(LoggedIn))
  end;
  if (InLargeGrave) then
  begin
    FS := 0;
    Debug('In Large Grave');
    repeat
      Debug('Walking to grave door(large)');
      if (not(InLargeGrave)) then Break;
      if (DetermineTeamToJoin = 'Red') then
        SPS_WalkToPos(Point(960, 4995))
      else
        SPS_WalkToPos(Point(415, 5075));
      FFlag(0);
      repeat
        if (DetermineTeamToJoin = 'Red') then
        begin
          if (FindRedBarrier) then
          begin
            Mouse(665, 129, 15, 15, True);
            FFlag(0);
            Exit;
          end;
        end else
        begin
          if (FindBlueBarrier) then
          begin
            Mouse(585, 49, 15, 15, True);
            FFlag(0);
            Exit;
          end;
        end;
        Inc(FS);
        if (FS > 1) then Break;
        Wait(500 + Random(1500));
      until False
    until (not(InLargeGrave)) or (not(InGame)) or (not(LoggedIn))
  end else
  begin
    if (AttackPlayer) then
      Wait(1250 + Random(2000));
  end;

end;


procedure STARTBLUEWAITINGROOM;
begin
end;

function GetBlueWaitingRoom: TPoint;
var
  A, X, Y: Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, SW_WATERCOLOR, MMX1, MMY1, MMX2, MMY2, 11);
  atpa := SplitTPAEx(TPA, 25, 25);
  SortATPASize(ATPA, True);
  DebugATPA(atpa, '');

  for A := 0 to High(ATPA) do
  begin
    bBox := GetTPABounds(ATPA[A]);
    Debug('Water width: '+ToStr(bBox.X2 - bBox.X1)+'');
    Debug('Water height:'+ToStr(bBox.y2 - bBox.y1)+'');
    if (bBox.X2 - bBox.X1 >= 8) and (bBox.Y2 - bBox.Y1 >= 50) then
    begin
      MiddleTPAEx(ATPA[A], X, Y);
      if (X < 1) or (Y < 1) then
        Continue;
      Result := Point(X, Y);
      Debug('Water TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
      Exit;
    end;
    wait(5);
  end;
end;

function GetBlueWaitingDoor: TPoint;

var
  A, X, Y : Integer;
  TPA : TPointArray;
  ATPA : T2DPointArray;
  bBox : TBox;
  TP : Tpoint;
begin
  if not LoggedIn then Exit;
  FindColorsTolerance(TPA, DOORCOLOR, MMX1, MMY1, MMX2, MMY2, 15);
  ATPA := TPAToATPAEx(TPA, 1, 3);
  SortATPASize(ATPA, False);
  TP := GetBlueWaitingRoom;
  SortATPAFrom(ATPA, TP);
  DebugATPA(ATPA, '');
  for A := High(ATPA) downto 0 do
  begin
    MiddleTPAEx(ATPA[A], X, Y);
    Debug('Distance from water TPoint: '+ToStr(Distance(x, y, TP.X, TP.Y)));
    if (Distance(x, y, TP.X, TP.Y) < 40) then
    begin
      bBox := GetTPABounds(ATPA[A]);
      Debug('Door width: '+ToStr(bBox.X2 - bBox.X1)+'');
      Debug('Door height: '+ToStr(bBox.y2 - bBox.y1)+'');
      if (bBox.X2 - bBox.X1 >= 0) and (bBox.Y2 - bBox.Y1 >= 3) then
      begin
        if (X < 1) or (Y < 1) then
          Continue;
        Result := Point(X, Y);
        Debug('Door TPoint: '+ToStr(X)+', '+ToStr(Y)+'');
        Exit;
      end;
    end;
    wait(10);
  end;
end;

function WalkToBlueWaitingEntrance: Boolean;
var
  TP: TPoint;
begin
  if not LoggedIn then Exit;
  if (InGame) then Exit;

  TP := GetBlueWaitingDoor;
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance');
  TP := GetBlueWaitingRoom;                   //IF BLUE DOOR IS COVERed ...
  if (TP.X > 0) and (TP.Y > 0) then
  begin
    Mouse(TP.X, TP.Y, 6, 6, True);
    Wait(RandomRange(750, 2500));
    FFlag(0);
    Result := True;
    Exit;
  end;
  Debug('Failed walking to blue entrance : 2');
end;


function EnterBlueWaitingRoom: Boolean;
begin
  if (InWaitingRoom) Then Exit;
  if InGame then Exit;
  if (FindCustomTPA('BlueWaitingRoom', 'W', SRL_ANGLE_LOW, MS_BARRIER_BLUE, 162, 68, 363, 218, 30, 3, 3, 1, 3, True, 65, 2, 2, True, 'arrier', 'arrier')) then
  begin
    if (ByPassWarning) then
    begin
      Result := True;
      FFlag(0);

      Wait(1500 + Random(1500));
      if (Random(3) = 1) then
      begin
        Mouse(MSCX - 150, MSCY, 40, 40, True);
        FFlag(0);
        Wait(1500 + Random(1500));
      end;
      Exit;
    end else
    begin
      if (Random(3) = 1) then
      begin
        Mouse(MSCX - 100, MSCY, 40, 40, True);
        FFlag(0);
        Wait(1500 + Random(1500));
      end;
      Exit;
    end;
  end;
end;

procedure ENDBLUEWAITINGROOM;
begin
end;



function GetLoc: String;
begin
  if (not(InGame)) then //If not in the game
  begin
    if (NearBank) then // If we are near the bank
    begin
      Result := 'LeaveBank';//Tell main loop to walk toward the middle of the two islands
      Exit;
    end else   // if we are not in game and not by bank
    begin
      if (InWaitingRoom) then // check if were in waiting room (Simple boolean)
      begin
        Result := 'Waiting Room';
        InWaitingRoom2 := True;
        Exit;
      end;                  //if not, lets GOOO!
      Result := 'EnterWaitingRoom';
    end;
  end else
  begin
    Result := 'InGame';  //in game time
  end;

end;


begin
  Smart_Server := 44;
  Smart_Members := True;
  Smart_Signed := True;
  Smart_SuperDetail := False;
  SetupSRL;
  Reincarnate:=true;
  SPS_Setup(RUNESCAPE_SURFACE,['0_12','1_11','1_12','1_13', '2_12']);

  DeclarePlayers;
  ActivateClient;
  Mouse(88, 493, 8, 8, True);//Set chat -> Game
  TeamOn := 'Blue'; //for now just set this...
  inwaitingroom2 := false;   //leave this to true if ur starting in the aiting room or ion the graveyard
 // writeln(ingraveyard);
  //Getgraveyarddoor;
  //enterRedwaitingroom;
  //findbarriergame(162, 68, 363, 218);

  //whitedotsonscreen;

  //leavecrowdedgrave;
 // insmallgrave;
  // writeln(inGraveFlood(93));
  Writeln(SPS_GetMyPos);
  //Point(719, 5296), Point(758, 5328))
  //writeln(inlargegrave);
  // terminatescript;
  repeat
    if (InGame) then
    begin
      Disguise('InGame');
    end;
    if (InWaitingRoom) then
      Disguise('InWaitingRoom');
    //if (Random(2) = 1) then Debug(GetLoc);    //So the debug box doesnt get spammed
    case GetLoc of
      'LeaveBank':
      begin
        if (not(SPS_WalkToPos(Point(685, 5300)))) then
        Walking(6713205, 15, Point(627, 146), 5, 5); // if Near the bank walk south to the middle of both boxes
      end;
      'EnterWaitingRoom':
      begin
        if (not(CompassNorth)) then // If your compass is east/west already from a previous attempt, then just try again
        begin
          if (DetermineTeamToJoin = 'Red') then
            EnterRedWaitingRoom;
          if (DetermineTeamToJoin = 'Blue') then
            EnterBlueWaitingRoom;

        end else
        begin
          if (DetermineTeamToJoin = 'Red') then
          begin
            if (WalkToRedWaitingEntrance) then  //Walks to the red
            begin
              EnterRedWaitingRoom;
            end;
          end;
          if (DetermineTeamToJoin = 'Blue') then
          begin
            if (WalkToBlueWaitingEntrance) then  //Walks to the blue
            begin
              EnterBlueWaitingRoom;
            end;
          end;
        end;
      end;
      'WaitingRoom':
      begin
        InWaitingRoom2 := True;
        Wait(1250 + Random(1250));
        if (Random(30) = 5) then
          MMouse(Random(500), Random(500), 0, 0);
      end;
      'InGame':
      begin
        GameLoop;
      end;
    end;
  until False
end.
